学习笔记


# 递归 
 1. 终止条件 terminator 
 2. 当前层处理逻辑 Process current level logic
 3. 下一层处理 drill down，有些状态参数改变了但没有破坏当前层的梦境
 4. 如果需要清理当前层的状态， Reverse the current level status,  如果使用的是当前函数栈保存当前层状态不需要清理，如果有全局变量等需要恢复。
## 递归思维训练
 1. 人脑喜欢暴力求解， 不要人肉递归（初阶画递归树，高阶尽量寻找**重复子问题**
 2. 寻找最近重复子问题，计算机擅长重复子问题。 
 3. 数学归纳法， 先尝试最基本的条件下是否成立，再看N+1是否成立。

总结： 写递归程序，先自顶向下，先写好terminator终止条件防止程序进入死循环；发现重复子问题；处理好当前层业务逻辑，并考虑必要的**剪枝条件**(最优化减枝， 可行性减枝)。

# 分治 (divide and conquer)
### 核心思想： 
其实也是递归，替换递归第4步为合并结果。
**关键点**： 寻找重复子问题，终止条件是再也没有重复子问题需要解决。
### 快速排序
1. 核心思想使用第一个元素或者最后一个元素座位povit元素分割数组，使得[0, povit-1] povit [povit + 1, lenght -1]
2. [0, povit-1]数据都小于povit， [povit+1, length-1]都大于povit元素。
3. 插入povit 到中间位置。
从1开始重新左右两边分别执行。

### 归并排序
1. 分割nums数组，[0,mid], [mid+1, length-1]
2. lo == hi 就只剩一个宝宝了，
3. 递归开始回来了，合并数据，申请临时合并空间保存数据。
4. 把临时合并后数据返回去。

例题： 快速幂

# 回溯 (Backtracing)
### 核心思想： 
寻找terminator条件，链表有两种返回截止条件，
a. left == NULL && right == NULL:  访问到子叶子就返回
b. root == NULL 返回即访问到空节点返回

