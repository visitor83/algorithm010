学习笔记


# DP

## 概念

1. **最优子结构**: 问题最优解包含子问题最优解, 用来决策
2. 重叠子问题: 递归树里有节点，在递归过程中重复计算。
3. 无后效性: 推到后面阶段状态，只关心前面阶段状态。
              某阶段状态一旦确认，不受后面阶段决策影响。

## 例题
[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)  
思想:  
递归: 字符尾部开始递归  
1. 截止条件: a, b字符串到达头部, 开始递归返回求解。
2. 重复问题：当前递归层的解,由以下两个问题组成重复问题。
   - a[i]==b[i] 解+1； a[i] != b[i] ， 
   - a[i-1],b[i-1] 的解，那个最大返回。


DP: dp[i] 已位置i结尾的最大公共子序列数目。
1. 最优子结构:
2. 重复计算:
3. 无后效性:
 


[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)  
思想： 
暴力 - 从左上角开始遍历，找到1位置cur, 从cur **新增** 一行一列判断是否全都是1， 从cur对角一步走是否为1。  
DP - dp[i][j] - 以[i,j] 为右下角，且只包含1的最大正方形边长。 
子结构 -  
从左上角开始， 左到右，上到下，这么走 **无后效性** dp [i-1][j] -- 已经求过了?
```C
dp[i][j] = 1: 加入 - dp[i-1][j-1] = 1 , dp [i-1][j] =1, dp[i][j-1] = 1
                        -------------+-------------------|
                                已经求过了  
    以上三个里求最小边长 + 1, 想成拼木桶，只能选择最短的木板。如果最小边长0，从当前1开始计算最长边，初始边长1。
dp[i][j] = 0 :不加入： dp[i][j] = 0 ||  dp [i-1][j] = 0 || dp[i][j-1] = 0  边长为0 。 
```

[621 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)  
思想： 贪心策略,每次按任务数递减调度，反证否则空闲时间会拉长总时间。  
截止条件： 没有可调度任务  
重复问题：  
1. table 长度比 n 大,  无停顿
2. table 长度比 n 小， 每次都需要停顿
3.  最后剩余不满n 时，直接跳出   

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)  
思想：  
递归 - 
1. 截止条件: 起点。
2. 重复问题: 求x - 1和y - 1的值，两者之和是当前递归层的解。  

DP : dp[i][j]当前点的路径组合树。  
1. 最优子结构: 向右走的累计值， 向下走的步数累计值。 只有这两个子问题。
2. 无后效性： 从左到右，从上到下计算，不会走回头路，改变之前的决策值，满足。
3. 重复计算： 递归树存在重复计算路径。
4. basecase: 第一行，第一列，只有一种取值。 

概念： 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。  