学习笔记


# DP

## 概念

1. **最优子结构**: 问题最优解包含子问题最优解, 用来决策
2. 重叠子问题: 递归树里有节点，在递归过程中重复计算。
3. 无后效性: 推到后面阶段状态，只关心前面阶段状态。
              某阶段状态一旦确认，不受后面阶段决策影响。

## 例题
[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)  
思想:  
递归: 字符尾部开始递归  
1. 截止条件: a, b字符串到达头部, 开始递归返回求解。
2. 重复问题：当前递归层的解,由以下两个问题组成重复问题。
   - a[i]==b[i] 解+1；  加入LCS集合
   - a[i] != b[i]。 a[i-1],b[i-1] 的解，那个最大返回。 无法加入，向上传递解。


二维DP表: dp[i][j] 位置i, j结尾的最大公共子序列数目。
1. 最优子结构:  递归重复问题，有且只有两个子问题结构，做决策即可。
2. 重复计算:
3. 无后效性: 递归撞到字符0位置触底反弹，后面再访问不会改变之前递归树已求解的值, DP 顺序从0位置开始计算。
4. basecase: 构造 第一行列为0。

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)
思路：  
递归： 自底置顶， 
1. 截止条件： 碰到三角形第一个元素返回递归 。
2. 重复问题： 求下一层row + 1, (col, col +1)列的最小值+ 当前层的值。

DP: DP[i][j]，从底部到i行，j列的最小路径。  
1. 最优子结构： row + 1行， (col, col+1) 决策最小值。
2. 重复计算： 有
3. 无后效性： 求解路径从三角形底部向上求解，每层计算不会影响之前层决策结果。
 


[221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)  
思想：   
暴力 : 从左上角开始遍历，找到1位置cur, 从cur **新增** 一行一列判断是否全都是1， 从cur对角一步走是否为1。  
DP : dp[i][j] - 以[i,j] 为右下角，且只包含1的最大正方形边长。 
子结构 -  
从左上角开始， 左到右，上到下，这么走 **无后效性** dp [i-1][j] -- 已经求过了?
```C
dp[i][j] = 1: 加入 - dp[i-1][j-1] = 1 , dp [i-1][j] =1, dp[i][j-1] = 1
                                       | -------------+-------------------|
                                                      已经求过了  
    以上三个里求最小边长 + 1, 想成拼木桶，只能选择最短的木板。如果最小边长0，从当前1开始计算最长边，初始边长1。
dp[i][j] = 0 :不加入： dp[i][j] = 0 ||  dp [i-1][j] = 0 || dp[i][j-1] = 0  边长为0 。 
```

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)  
思想：   
贪心：找到从左侧开始最小点保持住，j 向右侧找与之最大差, **只能买卖一次**  
DP二维：  dp[i][0/1] - 当天持有股票 的利润, 0/1表示当前状态持有，没持有股票。  
``` C
        // 手里没有股票 -   前一天没股票，第i天也没买
        //            -   前一天有股票， 第i天卖了, 利润 更新
        dp[0][i] = fmax(dp[0][i - 1], prices[i] + dp[1][i - 1]);
        // 手里有股票 - 前一天有股票，第i天啥也没干
        // - 前一天没股票，第i天买
        // dp[i][1] = fmax(dp[i-1][1], dp[i-1][0] - prices[i]) ;
        dp[1][i] = dp[1][i] + fmax(dp[1][i - 1], -prices[i]);
``` 

[621 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)  
思想：  
贪心,每次按任务数递减调度，否则空闲时间会拉长总时间。  
截止条件： 没有可调度任务  
重复问题：  
1. table 长度比 n 大,  无停顿
2. table 长度比 n 小， 每次都需要停顿
3.  最后剩余不满n 时，直接跳出   

[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)  
思想：  
递归 - 
1. 截止条件: 撞到起点反弹。
2. 重复问题: 求x - 1和y - 1的值，两者之和是当前递归层的解。  

DP : dp[i][j]当前点的路径组合树。  
1. 最优子结构: 向右走的累计值， 向下走的步数累计值。 只有这两个子问题。
2. 无后效性： 从左到右，从上到下计算，不会走回头路，不会改变之前的决策值，满足。
3. 重复计算： 递归树存在重复计算路径。
4. basecase: 第一行，第一列，只有一种取值。 

概念： 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。  

[312 戳气球]
1. 有重复子问题吗？ 有独立子问题吗? 从中间分割两个独立区间 分治思想， 不行！！[left, i], [i+1, right]不是独立子问题  
   [left, i]区间内删除元素后，区间内的结果受[i+1, right]区间影响，不行！！  
   转换问题： [left, right]区间内增加i 气球； 增加后区间为[left, i], [i, right]，继续增加气球；左右区间成为独立子问题
[91 解码方法]
1. 有重复子问题吗？ 是每个字符作为一层，还是一层迭代进行？一个字符作为一层，